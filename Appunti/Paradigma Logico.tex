\documentclass[12pt]{extarticle}
\usepackage[top=1.5cm, bottom=1.5cm, left=1cm, right=1cm]{geometry}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{color}
\usepackage{multicol}


\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{
  frame=none,
  language=C,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\normalsize\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3
}

\title{Paradigma Logico}
\author{R.S}

\begin{document}
\maketitle

\section*{Sintassi}

\begin{itemize}
  \item Si usa la sintassi della logica del primo ordine $\rightarrow$ \textbf{predicate calculus}
  \item Componenti della sintassi:
  \begin{itemize}
    \item Simboli logici (uguali per tutti i linguaggi): 
    \begin{itemize}
      \item connettivi $\rightarrow$ $\wedge, \vee , \lnot, \dots$ 
      \item quantificatori $\rightarrow$ $\forall, \exists$
      \item costanti $\rightarrow$ true, false
      \item variabili $\rightarrow$ lettere maiuscole come X,Y,Z
    \end{itemize}
    \item Simboli non logici:
    \begin{itemize}
      \item predicati $\rightarrow$ padre(X,Y)
      \item funzioni $\rightarrow$ $f(a,b)$
      \item costanti $\rightarrow$ a, b, \dots
    \end{itemize}
    \item Termini $\rightarrow$ elementi base della sintassi: 
    \begin{itemize}
      \item una variabile può essere un termine, così come una costante
      \item i termini possono essere \textbf{composti} applicando funzioni ad altri termini $\rightarrow$ $f(a,X)$
      \item termini \textbf{ground} $\rightarrow$ termini che non contengono variabili (es. $f(a,b)$)
    \end{itemize}
    \item Formule:
    \begin{itemize}
      \item atomi $\rightarrow$ applicazione di un predicato $\rightarrow$ fratello(X,Y)
      \item formule complesse $\rightarrow$ fratello(X,Y) $\wedge$ fratello(Y,Z) 
      \item quantificazioni $\rightarrow$ $\forall$ X $\exists$ Y padre(X,Y)
    \end{itemize}
    \item  Clausole:
    \begin{itemize}
      \item definizione: $H:$ -$ A_1, A_2, \dots, A_n$ con $n \ge 0$ 
            \\ la definizione viene interpretata come $A_1 \wedge A_2 \wedge \dots \wedge A_n \rightarrow H$
      \item esempio di clausola definita:
      \begin{lstlisting}
        genitore(X,Y) :- padre(X,Y)
        antenato(X,Y) :- genitore(X,Y)
        antenato(X,Y) :- genitore(X,Z), antenato(Z,Y)
      \end{lstlisting}
      \item Fatti $\rightarrow$ clausole con corpo \textbf{vuoto}
      \item Programma Logico $\rightarrow$ insieme di clausole definite
      \item Goal (query) $\rightarrow$ sequenza di atomi da valutare e dimostrare
      \begin{itemize}
        \item esempio: ?- genitore(X,mario)
      \end{itemize}
    \end{itemize}
  \end{itemize}
\end{itemize}

\newpage

\section*{Variabili logiche e unificazione}
\begin{itemize}
  \item Applicare una clausola $\rightarrow$ unificare la query con la clausola stessa
  \item Variabile logica: può essere istanziata una sola volta $\rightarrow$ può essere associata a termini non ground
  \item Unificazione $\rightarrow$ soluzione di equazione tra termini
  \begin{itemize}
    \item equazione $\rightarrow$ $f(X,b) = f(a, Y)$, soluzione $\rightarrow$ $\{X/a, Y/b\}$
  \end{itemize}
  \item  Algoritmo di \textbf{Unificazione} (Martelli-Montanari)
  \begin{itemize}
    \item determina se un insieme di equazioni tra termini è risolvibile
    \item restituisce una \textbf{forma risolta} $\rightarrow$ MGU (most general unifier)
    \item obiettivo:
    \begin{itemize}
      \item insieme $\{s_1 = t_1, \dots, s_n = t_n\}$
      \item restituzione della MGU $\theta$ tale che $s_i\theta = t_i\theta$ $\forall i$ (fallimento altrimenti)
    \end{itemize}
    \item algoritmo incrementale $\rightarrow$ riduce la complessità dei termini ad ogni passo
    \item crea valori \textbf{parziali} che vengono poi raffinati
    \item è la base del motore di inferenza dei linguaggi logici
  \end{itemize}
  \item Sostituzione:
  \begin{itemize}
    \item una \textbf{sostituzione} è una funzione che associa variabili a termini
    \item definizione: $\theta = \{X_1/t_1, X_2/t_2, \dots X_n/t_n\}$
    \item esempio: $\theta = \{X/a, Y/f(b)\}$ $\rightarrow$ $\theta(X) = a, \theta(Y) = f(b)$
    \item applicazione di una sostituzione: si denota con $t\theta$ il termine che si ottiene sostituendo \\
          tutte le occorrenze di t secondo $\theta$
    \item \textbf{composizione} di sostituzioni:
    \begin{itemize}
      \item due sostituzioni $\rightarrow$ $\theta = \{X/a\}$ e $\sigma = \{Y/X\}$
      \item composizione $\rightarrow$ $\theta \circ \sigma = \{Y/a, X/a\}$
    \end{itemize}
  \end{itemize}
\end{itemize}

\section*{Risoluzione SLD}
\begin{itemize}
  \item parte da un goal iniziale e da un programma $\rightarrow$ risolve i goal scegliendo clausole appropriate
  \item una sequenza di applicazioni produce una \textbf{dimostrazione} (SLD refutation)
  \item la dimostrazione viene fatta per backtracking $\rightarrow$ ricerca di alternative in caso di fallimento
  \item esempio ProLog:
  \begin{lstlisting}
    //definizione
    antenato(X,Y) :- genitore(X,Y)
    antenato(X,Y) :- genitore(X,Z), antenato(Z,Y)
    //fatti definiti
    genitore(luca, mario)
    genitore(mario, giulia)
    //query
    ?- antenato(luca, giulia) //risposta attesa -> TRUE
  \end{lstlisting}
\end{itemize}

\newpage

\section*{Universo di Herbrand}
\begin{itemize}
  \item Insieme di tutti i termini costruibili da un insieme di simboli
  \item Termini costruiti a partire da costanti e funzioni $\rightarrow$ tutti ground
  \item esmepio: $\{a, f(a), f(f(a)), f(f(f(a))) \dots\}$
\end{itemize}

\section*{Interpretazione dichiarativa e procedurale}
\begin{itemize}
  \item Dichiarativa $\rightarrow$ significato \textbf{logico} del programma
  \item Procedurale $\rightarrow$ esecuzione vera e propria del programma
  \item Chiamate procedurali:
  \begin{itemize}
    \item chiamata procedurale $\rightarrow$ richiesta di \textbf{dimostrazione} di un goal
    \item se esiste una clausola compatibile continuo la computazione, altrimenti la chiamata fallisce
  \end{itemize}
  \item Computazione con risoluzione SLD
  \begin{itemize}
    \item regola inferenziale centrale per la computazione logica
    \item una derivazione \textbf{SLD} produce una sequenza di goal via via più semplici
    \item una \textbf{refutazione} SLD termina con un goal vuoto (successo)
    \item risultato $\rightarrow$ sostituzione dei valori ai parametri (answer substitution)
  \end{itemize}
  \item Backtracking:
  \begin{itemize}
    \item computazione logica \textbf{non deterministica}
    \item fallimento $\rightarrow$ torna indietro per esplorare alternative differenti
    \item inefficienza $\rightarrow$ dovuta alla quantità combinatoria di passi
  \end{itemize}
\end{itemize}

\section*{Clausole defnite e generali}


\end{document}